#!/usr/bin/env python3
import json
import os
import re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]


def parse_cargo_lock(lock_path: Path):
    deps = []
    if not lock_path.exists():
        return deps

    name = version = source = None
    in_pkg = False
    with lock_path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.rstrip("\n")
            if line.strip() == "[[package]]":
                # flush previous
                if in_pkg and name and version:
                    deps.append({
                        "name": name,
                        "version": version,
                        "source": source or "",
                    })
                # start new
                name = version = source = None
                in_pkg = True
                continue
            if not in_pkg:
                continue
            if line.startswith("name = "):
                name = line.split("=", 1)[1].strip().strip('"')
            elif line.startswith("version = "):
                version = line.split("=", 1)[1].strip().strip('"')
            elif line.startswith("source = "):
                source = line.split("=", 1)[1].strip().strip('"')
        # flush last
        if in_pkg and name and version:
            deps.append({
                "name": name,
                "version": version,
                "source": source or "",
            })

    # Filter to third-party: entries with a source (registry+/git+). Exclude workspace crates.
    out = []
    seen = set()
    for d in deps:
        s = d.get("source", "")
        key = (d["name"], d["version"]) 
        if key in seen:
            continue
        # Exclude workspace crates by heuristic: no source or local codex-* crates
        if not s:
            continue
        if d["name"].startswith("codex-"):
            continue
        out.append({
            "name": d["name"],
            "version": d["version"],
            "license": "UNKNOWN",
            "source": s,
            "ecosystem": "Rust",
        })
        seen.add(key)
    # Sort for stability
    out.sort(key=lambda x: (x["name"].lower(), x["version"]))
    return out


def parse_npm_lock(lock_path: Path):
    deps = []
    if not lock_path.exists():
        return deps
    data = json.loads(lock_path.read_text(encoding="utf-8"))
    packages = data.get("packages", {})
    for path, meta in packages.items():
        if path == "":
            # root package
            continue
        version = meta.get("version")
        license_ = meta.get("license", "UNKNOWN")
        name = meta.get("name")
        if not name:
            # derive from node_modules/... path
            # support scoped packages
            m = re.search(r"node_modules/(.*)", path)
            if not m:
                continue
            name = m.group(1)
        deps.append({
            "name": name,
            "version": version or "",
            "license": license_,
            "source": "npm registry",
            "ecosystem": "Node",
        })
    # de-duplicate by name@version
    uniq = {}
    for d in deps:
        key = (d["name"], d["version"]) 
        uniq[key] = d
    out = list(uniq.values())
    out.sort(key=lambda x: (x["name"].lower(), x["version"]))
    return out


def render_markdown(rust_deps, node_deps):
    lines = []
    lines.append("# THIRD-PARTY-NOTICES")
    lines.append("")
    lines.append("This repository is distributed under Apache-2.0 (see the root LICENSE).")
    lines.append("This document lists third-party dependencies that may be included in distributed artifacts,")
    lines.append("together with their license information.")
    lines.append("")
    lines.append("Note: Generated in an offline environment. Cargo.lock does not contain license")
    lines.append("fields; entries marked as UNKNOWN may require online tooling to complete.")
    lines.append("")
    lines.append("Generated by scripts/gen_third_party_notices.py (using npm's package-lock.json and Rust's Cargo.lock).")
    lines.append("")
    lines.append("## Rust dependencies (Cargo.lock)")
    if not rust_deps:
        lines.append("- None (or Cargo.lock not detected)")
    else:
        for d in rust_deps:
            lines.append(f"- {d['name']} {d['version']} — License: {d['license']} ({d['source']})")
    lines.append("")
    lines.append("## Node dependencies (package-lock.json)")
    if not node_deps:
        lines.append("- None (or package-lock.json not detected)")
    else:
        for d in node_deps:
            lines.append(f"- {d['name']} {d['version']} — License: {d['license']}")
    lines.append("")
    lines.append("---")
    lines.append("")
    lines.append("Suggestions:")
    lines.append("- Rust: In an online environment, use cargo-about/cargo-license to generate a complete")
    lines.append("  license report and replace UNKNOWN entries.")
    lines.append("- Node: After installing dependencies, use `npm ls --json` or `license-checker` to verify.")
    return "\n".join(lines) + "\n"


def main():
    rust_lock = ROOT / "codex-rs" / "Cargo.lock"
    node_lock = ROOT / "codex-cli" / "package-lock.json"

    rust_deps = parse_cargo_lock(rust_lock)
    node_deps = parse_npm_lock(node_lock)

    md = render_markdown(rust_deps, node_deps)
    out_root = ROOT / "THIRD-PARTY-NOTICES.md"
    out_root.write_text(md, encoding="utf-8")

    # Also mirror to codex-cli for npm package inclusion
    out_cli = ROOT / "codex-cli" / "THIRD-PARTY-NOTICES.md"
    out_cli.write_text(md, encoding="utf-8")

    print(f"Wrote {out_root}")
    print(f"Wrote {out_cli}")


if __name__ == "__main__":
    main()
